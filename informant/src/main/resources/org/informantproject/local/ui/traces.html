<!doctype html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Traces</title>
<!-- not using CDN hosted js files since the embedded ui is typically for monitoring
     an application on a local machine / local network so this should be faster -->
<link rel="stylesheet" href="resources/jqueryui/1.8.16/themes/ui-lightness/jquery.ui.all.css">
<script type="text/javascript" src="resources/jquery/1.7/jquery.min.js"></script>
<script type="text/javascript" src="resources/jqueryui/1.8.16/jquery.ui.core.min.js"></script>
<script type="text/javascript" src="resources/jqueryui/1.8.16/jquery.ui.widget.min.js"></script>
<script type="text/javascript" src="resources/jqueryui/1.8.16/jquery.ui.button.min.js"></script>
<script type="text/javascript" src="resources/jqueryui/1.8.16/jquery.ui.datepicker.min.js"></script>
<script type="text/javascript" src="resources/dateformat/1.2.3/date.format.js"></script>
<script type="text/javascript" src="resources/handlebars/1.0.0.beta.3/handlebars.js"></script>
<script type="text/javascript" src="resources/flot/0.7/jquery.flot.min.js"></script>
<script type="text/javascript" src="resources/flot/0.7/jquery.flot.selection.min.js"></script>

<script id="tracestemplate" type="text/x-handlebars-template">
{{#traces}}
<div>
{{#if stuck}}<b>{{#if completed}}UN{{/if}}STUCK</b><br>{{/if}}
start: {{date start}}<br>
duration: {{nanostomillis duration}} milliseconds<br>
{{#if username}}username: {{username}}<br>{{/if}}
threadName(s): {{threadNames}}<br>
root context:<br>
{{#first spans}}
{{#eachentry contextMap}}{{/eachentry}}
{{/first}}
spans:<br>
{{#spans}}
  &nbsp;&nbsp;+{{nanostomillis offset}}&nbsp;&nbsp;&nbsp;{{nanostomillis duration}}&nbsp;&nbsp;&nbsp;{{description}}<br>
  {{#if index}}  
  {{#eachentry contextMap}}{{/eachentry}}
  {{/if}}
{{/spans}}
merged stack trace:<br>
{{#mergedstacktrace mergedStackTreeRootNodes}}{{/mergedstacktrace}}
</div>
{{/traces}}
</script>
<script type="text/javascript">
  Handlebars.registerHelper('date', function(timestamp) {
      return new Date(timestamp).format("m/d/yy h:MM:ss.l TT (Z)");
    });
  Handlebars.registerHelper('nanostomillis', function(nanos) {
      return (nanos / 1000000).toFixed(1);
    });
  Handlebars.registerHelper('first', function(array, fn) {
      return fn(array[0]);
    });
  Handlebars.registerHelper('eachentry', function(context, block) {
      var ret = "";
      for (var prop in context) {
        ret = ret + '&nbsp;&nbsp;&nbsp;&nbsp;' + prop + ": " + JSON.stringify(context[prop]) + "<br>";
      }
      return ret;
    });
  Handlebars.registerHelper('mergedstacktrace', function(rootNodes, block) {
      var totalSampleCount = 0;
      for (var i = 0; i < rootNodes.length; i++) {
        totalSampleCount += rootNodes[i].sampleCount;
      }
      return curr(rootNodes, 0, totalSampleCount);
    });
  function curr(childNodes, level, totalSampleCount) {
    var ret = '';
    // order child nodes by sampleCount (descending)
    childNodes.sort(function(a, b) { return b.sampleCount - a.sampleCount });
    for (var i = 0; i < childNodes.length; i++) {
      var childNode = childNodes[i];
      var stackTraceElement = childNode.stackTraceElement;
      ret += '&nbsp;&nbsp;<span style="display: inline-block; width: 4em">';
      var samplePercentage = (childNode.sampleCount / totalSampleCount) * 100;
      ret += samplePercentage.toFixed(1);
      ret += '%</span>'
      for (var j = 0; j < level; j++) {
        ret += '&nbsp;';
      }
      ret += stackTraceElement + '<br>';
      if (childNode.singleLeafState) {
        ret += '&nbsp;&nbsp;<span style="display: inline-block; width: 4em">';
        ret += samplePercentage.toFixed(1);
        ret += '%</span>'
        for (var j = 0; j < level; j++) {
          ret += '&nbsp;';
        }
        ret += '&nbsp;' + childNode.singleLeafState + '<br>';
      } else if (childNode.leafThreadStateSampleCounts) {
        // TODO generate a test case that produces multiple thread states for a single node
        ret += JSON.stringify(childNode.leafThreadStateSampleCounts) + '<br>';
      }
      ret += curr(childNode.childNodes, level + 1, totalSampleCount);
    }
    return ret;
  }
  var template;
  $(function() {
    template = Handlebars.compile($("#tracestemplate").html());
    Handlebars.registerPartial("span", $("#span-partial").html());
 
    var options = {
      legend: { show: false }, 
      series: {
        lines: { show: true },
        points: { show: true }
      },
      xaxis: { mode: "time" },
      yaxis: { ticks: 10 },
      selection: { mode: "xy" }
    };
 
    var overviewOptions = {
      legend: { show: true, container: $("#overviewLegend") },
      series: {
        lines: { show: true, lineWidth: 1 },
        shadowSize: 0
      },
      xaxis: { mode: "time", ticks: 1 },
      yaxis: { ticks: 3},
      grid: { color: "#999" },
      selection: { mode: "xy" }
    };
    
    var rangeFrom;
    var rangeTo;

    function plotFullDate(date) {
      rangeFrom = date.getTime();
      rangeTo = rangeFrom + 24 * 60 * 60 * 1000; // rangeFrom + 24 hours
      gettracesummaries(rangeFrom, rangeTo);
    }
    function plott(data) {
      plot = $.plot($("#placeholder"), [data], options);
      overview = $.plot($("#overview"), [data], overviewOptions);

      // now connect the two
      $("#placeholder").bind("plotselected", function (event, ranges) {
        // clamp the zooming to prevent eternal zoom
        // also round xaxis to nearest millisecond
        ranges.xaxis.from = Math.floor(ranges.xaxis.from);
        ranges.xaxis.to = Math.ceil(ranges.xaxis.to);
        if (ranges.yaxis.to - ranges.yaxis.from < 0.00001)
          ranges.yaxis.to = ranges.yaxis.from + 0.00001;

        rangeFrom = ranges.xaxis.from + new Date(ranges.xaxis.from).getTimezoneOffset() * 60 * 1000;
        rangeTo = ranges.xaxis.to + new Date(ranges.xaxis.to).getTimezoneOffset() * 60 * 1000;
            
        // do the zooming
        plot = $.plot($("#placeholder"), [data],
                      $.extend(true, {}, options, {
                               xaxis: { min: ranges.xaxis.from, max: ranges.xaxis.to },
                               yaxis: { min: ranges.yaxis.from, max: ranges.yaxis.to }
                      }));

        // don't fire event on the overview to prevent eternal loop
        overview.setSelection(ranges, true);
      });
      $("#overview").bind("plotselected", function (event, ranges) {
        plot.setSelection(ranges);
      });
    }

    function gettracesummaries(from, to, low, high) {
      var queryString = 'from=' + from + '&to=' + to;
      if (low != undefined) {
        queryString += '&low=' + low;
      }
      if (high != undefined) {
        queryString += '&high=' + low;
      }
      $.getJSON('/traceSummaries?from=' + from + '&to=' + to, function(response) {
          // shift for timezone
          for (var i = 0; i < response.data.length; i++) {
            response.data[i][0] -= new Date(response.data[i][0]).getTimezoneOffset() * 60 * 1000;
          }
          plott(response.data)
        });
      $('#traces').html('');
    }
    function gettraces(from, to, low, high) {
      var queryString = 'from=' + from + '&to=' + to;
      if (low != undefined) {
        queryString += '&low=' + low;
      }
      if (high != undefined) {
        queryString += '&high=' + low;
      }
      $.getJSON('/traces?from=' + from + '&to=' + to, function(response) {
        $('#traces').html('');
        if (response.traces.length) {
          var html = template(response);
          $(html).appendTo('#traces');
          // for debugging:
          //$('<div>' + JSON.stringify(response.traces[0]) + '</div>').appendTo('#traces');
        } else {
          $('#traces').html('no data');
        }
      });
    }

    $("#datepicker").datepicker({
        onSelect : function(dateText, inst) {
            plotFullDate($(this).datepicker('getDate'));
          }
      });
    $("#showdetails").button();
    $("#showdetails").click(function() {
        gettraces(rangeFrom, rangeTo);
      });

    var d = new Date();
    d.setHours(0,0,0,0);
    $("#datepicker").datepicker("setDate", d);
    plotFullDate(d);
  });
</script>
</head>
<body>
  <h2>Traces</h2>
  <div>
    Date: <input type="text" id="datepicker">
  </div><br>
  <div style="float: left">
    <div id="placeholder" style="width: 600px; height: 200px"></div>
  </div>
  <div id="miniature" style="float: left; margin-left: 20px">
    <div id="overview" style="width: 300px; height: 100px"></div>
    <p id="overviewLegend" style="margin-left: 10px"></p>
  </div>
  <div style="clear: left"></div>
  <button id="showdetails">Show Details</button>
  <br>
  <br>
  <div id="traces"></div>
</body>
</html>
